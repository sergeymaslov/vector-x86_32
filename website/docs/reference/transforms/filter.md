---
last_modified_on: "2020-07-13"
component_title: "Filter"
description: "The Vector `filter` transform accepts and outputs `log` and `metric` events, allowing you to select events based on a set of logical conditions."
event_types: ["log","metric"]
function_category: "filter"
issues_url: https://github.com/timberio/vector/issues?q=is%3Aopen+is%3Aissue+label%3A%22transform%3A+filter%22
operating_systems: ["Linux","MacOS","Windows"]
sidebar_label: "filter|[\"log\",\"metric\"]"
source_url: https://github.com/timberio/vector/tree/master/src/transforms/filter.rs
status: "beta"
title: "Filter Transform"
unsupported_operating_systems: []
---

import Fields from '@site/src/components/Fields';
import Field from '@site/src/components/Field';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Vector `filter` transform
accepts and outputs [`log`][docs.data-model.log] and
[`metric`][docs.data-model.metric] events, allowing you to select events based
on a set of logical conditions.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/transforms/filter.md.erb
-->

## Configuration

<Tabs
  block={true}
  defaultValue="common"
  values={[{"label":"Common","value":"common"},{"label":"Advanced","value":"advanced"}]}>
<TabItem value="common">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "filter" # required
  inputs = ["my-source-or-transform-id"] # required

  # Condition
  condition.type = "check_fields" # optional, default
  condition."message.eq" = "this is the content to match against" # example
  condition."message.eq" = ["match this", "or this"] # example
  condition."message.contains" = "foo" # example
  condition."message.contains" = ["foo", "bar"] # example
  condition."environment.ends_with" = "-staging" # example
  condition."environment.ends_with" = ["-staging", "-running"] # example
  condition."message.regex" = " (any|of|these|five|words) " # example
  condition."environment.starts_with" = "staging-" # example
  condition."environment.starts_with" = ["staging-", "running-"] # example
```

</TabItem>
<TabItem value="advanced">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "filter" # required
  inputs = ["my-source-or-transform-id"] # required

  # Condition
  condition.type = "check_fields" # optional, default
  condition."message.eq" = "this is the content to match against" # example
  condition."message.eq" = ["match this", "or this"] # example
  condition."host.exists" = true # example
  condition."method.neq" = "POST" # example
  condition."method.neq" = ["POST", "GET"] # example
  condition."message.not_contains" = "some phrase to ignore" # example
  condition."unit.not_starts_with" = "sys-" # example
  condition."unit.not_ends_with" = ".device" # example
  condition."message.contains" = "foo" # example
  condition."message.contains" = ["foo", "bar"] # example
  condition."environment.ends_with" = "-staging" # example
  condition."environment.ends_with" = ["-staging", "-running"] # example
  condition."message.ip_cidr_contains" = "10.0.0.0/8" # example
  condition."message.ip_cidr_contains" = ["2000::/10", "192.168.0.0/16"] # example
  condition."message.regex" = " (any|of|these|five|words) " # example
  condition."environment.starts_with" = "staging-" # example
  condition."environment.starts_with" = ["staging-", "running-"] # example
```

</TabItem>
</Tabs>

<Fields filters={true}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"condition"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

### condition

The set of logical conditions to be matched against every input event. Only
messages that pass all conditions will be forwarded.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={"check_fields"}
  enumValues={{"check_fields":"Allows you to check individual fields against a list of conditions.","is_log":"Returns true if the event is a log.","is_metric":"Returns true if the event is a metric."}}
  examples={["check_fields","is_log","is_metric"]}
  groups={[]}
  name={"type"}
  path={"condition"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### type

The type of the condition to execute.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"},{"message.eq":["match this","or this"]}]}
  groups={[]}
  name={"`[field-name]`.eq"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.eq

Check whether a fields contents exactly matches the value specified. This may
be a single string or a list of strings, in which case this evaluates to true
if any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  groups={[]}
  name={"`[field-name]`.exists"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.exists

Check whether a field exists or does not exist, depending on the provided value
being `true` or `false` respectively.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"},{"method.neq":["POST","GET"]}]}
  groups={[]}
  name={"`[field-name]`.neq"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.neq

Check whether a fields contents does not match the value specified. This may be
a single string or a list of strings, in which case this evaluates to false if
any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.not_contains":"some phrase to ignore"},{"unit.not_starts_with":"sys-"},{"unit.not_ends_with":".device"}]}
  groups={[]}
  name={"`[field-name]`.not_`[condition]`"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"any"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.not_`[condition]`

Check if the given `[condition]` does not match.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.contains":"foo"},{"message.contains":["foo","bar"]}]}
  groups={[]}
  name={"`[field_name]`.contains"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.contains

Checks whether a string field contains a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.ends_with":"-staging"},{"environment.ends_with":["-staging","-running"]}]}
  groups={[]}
  name={"`[field_name]`.ends_with"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.ends_with

Checks whether a string field ends with a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.ip_cidr_contains":"10.0.0.0/8"},{"message.ip_cidr_contains":["2000::/10","192.168.0.0/16"]}]}
  groups={[]}
  name={"`[field_name]`.ip_cidr_contains"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.ip_cidr_contains

Checks whether an IP field is contained within a given [IP CIDR][urls.cidr]
(works with IPv4 and IPv6). This may be a single string or a list of strings,
in which case this evaluates to true if the IP field is contained within any of
the CIDRs in the list.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.regex":" (any|of|these|five|words) "}]}
  groups={[]}
  name={"`[field_name]`.regex"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.regex

Checks whether a string field matches a [regular expression][urls.regex].
Vector uses the [documented Rust Regex syntax][urls.rust_regex_syntax]. Note
that this condition is considerably more expensive than a regular string match
(such as `starts_with` or `contains`) so the use of those conditions are
preferred where possible.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.starts_with":"staging-"},{"environment.starts_with":["staging-","running-"]}]}
  groups={[]}
  name={"`[field_name]`.starts_with"}
  path={"condition"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.starts_with

Checks whether a string field starts with a string argument. This may be a
single string or a list of strings, in which case this evaluates to true if any
of the list matches.



</Field>
</Fields>

</Field>
</Fields>

## Examples

The `filter` transform is a simple conditional match, forwarding only those messages that pass all the conditions.
In this example, we drop all events that do not come from the host `gerry`:

```toml title="vector.toml"
[transforms.from_gerry]
  inputs = [ "somewhere" ]
  type = "filter"

  [transforms.from_gerry.condition]
    "host.eq" = "gerry"

[sinks.only_gerry]
  inputs = [ "from_gerry" ]
  type = "something"
```

Any event that does not match all of the conditions in the filter will be dropped by the transform.

## How It Works

### Complex Processing

If you encounter limitations with the `filter`
transform then we recommend using a [runtime transform][urls.vector_programmable_transforms].
These transforms are designed for complex processing and give you the power of
full programming runtime.

### Environment Variables

Environment variables are supported through all of Vector's configuration.
Simply add `${MY_ENV_VAR}` in your Vector configuration file and the variable
will be replaced before being evaluated.

You can learn more in the
[Environment Variables][docs.configuration#environment-variables] section.

[docs.configuration#environment-variables]: /docs/setup/configuration/#environment-variables
[docs.data-model.log]: /docs/about/data-model/log/
[docs.data-model.metric]: /docs/about/data-model/metric/
[urls.cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
[urls.regex]: https://en.wikipedia.org/wiki/Regular_expression
[urls.rust_regex_syntax]: https://docs.rs/regex/1.3.6/regex/#syntax
[urls.vector_programmable_transforms]: https://vector.dev/components/?functions%5B%5D=program
