---
last_modified_on: "2020-07-13"
component_title: "Reduce"
description: "The Vector `reduce` transform accepts and outputs `log` events, allowing you to combine multiple events into a single event based on a set of identifiers."
event_types: ["log"]
function_category: "aggregate"
issues_url: https://github.com/timberio/vector/issues?q=is%3Aopen+is%3Aissue+label%3A%22transform%3A+reduce%22
operating_systems: ["Linux","MacOS","Windows"]
sidebar_label: "reduce|[\"log\"]"
source_url: https://github.com/timberio/vector/tree/master/src/transforms/reduce
status: "beta"
title: "Reduce Transform"
unsupported_operating_systems: []
---

import Fields from '@site/src/components/Fields';
import Field from '@site/src/components/Field';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Vector `reduce` transform
accepts and outputs [`log`][docs.data-model.log] events, allowing you to
combine multiple events into a single event based on a set of identifiers.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/transforms/reduce.md.erb
-->

## Configuration

<Tabs
  block={true}
  defaultValue="common"
  values={[{"label":"Common","value":"common"},{"label":"Advanced","value":"advanced"}]}>
<TabItem value="common">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "reduce" # required
  inputs = ["my-source-or-transform-id"] # required
  identifier_fields = [] # optional, default

  # Ends when
  ends_when.type = "check_fields" # optional, default
  ends_when."message.eq" = "this is the content to match against" # example
  ends_when."message.eq" = ["match this", "or this"] # example
  ends_when."message.contains" = "foo" # example
  ends_when."message.contains" = ["foo", "bar"] # example
  ends_when."environment.ends_with" = "-staging" # example
  ends_when."environment.ends_with" = ["-staging", "-running"] # example
  ends_when."message.regex" = " (any|of|these|five|words) " # example
  ends_when."environment.starts_with" = "staging-" # example
  ends_when."environment.starts_with" = ["staging-", "running-"] # example
```

</TabItem>
<TabItem value="advanced">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "reduce" # required
  inputs = ["my-source-or-transform-id"] # required
  expire_after_ms = 30000 # optional, default
  flush_period_ms = 1000 # optional, default
  identifier_fields = [] # optional, default

  # Ends when
  ends_when.type = "check_fields" # optional, default
  ends_when."message.eq" = "this is the content to match against" # example
  ends_when."message.eq" = ["match this", "or this"] # example
  ends_when."host.exists" = true # example
  ends_when."method.neq" = "POST" # example
  ends_when."method.neq" = ["POST", "GET"] # example
  ends_when."message.not_contains" = "some phrase to ignore" # example
  ends_when."unit.not_starts_with" = "sys-" # example
  ends_when."unit.not_ends_with" = ".device" # example
  ends_when."message.contains" = "foo" # example
  ends_when."message.contains" = ["foo", "bar"] # example
  ends_when."environment.ends_with" = "-staging" # example
  ends_when."environment.ends_with" = ["-staging", "-running"] # example
  ends_when."message.ip_cidr_contains" = "10.0.0.0/8" # example
  ends_when."message.ip_cidr_contains" = ["2000::/10", "192.168.0.0/16"] # example
  ends_when."message.regex" = " (any|of|these|five|words) " # example
  ends_when."environment.starts_with" = "staging-" # example
  ends_when."environment.starts_with" = ["staging-", "running-"] # example

  # Merge strategies
  merge_strategies.method = "discard" # example
  merge_strategies.path = "discard" # example
  merge_strategies.duration_ms = "sum" # example
  merge_strategies.query = "array" # example
```

</TabItem>
</Tabs>

## Options

<Fields filters={true}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"ends_when"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

### ends_when

A condition used to distinguish the final event of a transaction. If this
condition resolves to true for an event the transaction it belongs to is
immediately flushed.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={"check_fields"}
  enumValues={{"check_fields":"Allows you to check individual fields against a list of conditions.","is_log":"Returns true if the event is a log.","is_metric":"Returns true if the event is a metric."}}
  examples={["check_fields","is_log","is_metric"]}
  groups={[]}
  name={"type"}
  path={"ends_when"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### type

The type of the condition to execute.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"},{"message.eq":["match this","or this"]}]}
  groups={[]}
  name={"`[field-name]`.eq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.eq

Check whether a fields contents exactly matches the value specified. This may
be a single string or a list of strings, in which case this evaluates to true
if any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  groups={[]}
  name={"`[field-name]`.exists"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.exists

Check whether a field exists or does not exist, depending on the provided value
being `true` or `false` respectively.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"},{"method.neq":["POST","GET"]}]}
  groups={[]}
  name={"`[field-name]`.neq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.neq

Check whether a fields contents does not match the value specified. This may be
a single string or a list of strings, in which case this evaluates to false if
any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.not_contains":"some phrase to ignore"},{"unit.not_starts_with":"sys-"},{"unit.not_ends_with":".device"}]}
  groups={[]}
  name={"`[field-name]`.not_`[condition]`"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"any"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.not_`[condition]`

Check if the given `[condition]` does not match.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.contains":"foo"},{"message.contains":["foo","bar"]}]}
  groups={[]}
  name={"`[field_name]`.contains"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.contains

Checks whether a string field contains a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.ends_with":"-staging"},{"environment.ends_with":["-staging","-running"]}]}
  groups={[]}
  name={"`[field_name]`.ends_with"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.ends_with

Checks whether a string field ends with a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.ip_cidr_contains":"10.0.0.0/8"},{"message.ip_cidr_contains":["2000::/10","192.168.0.0/16"]}]}
  groups={[]}
  name={"`[field_name]`.ip_cidr_contains"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.ip_cidr_contains

Checks whether an IP field is contained within a given [IP CIDR][urls.cidr]
(works with IPv4 and IPv6). This may be a single string or a list of strings,
in which case this evaluates to true if the IP field is contained within any of
the CIDRs in the list.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.regex":" (any|of|these|five|words) "}]}
  groups={[]}
  name={"`[field_name]`.regex"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.regex

Checks whether a string field matches a [regular expression][urls.regex].
Vector uses the [documented Rust Regex syntax][urls.rust_regex_syntax]. Note
that this condition is considerably more expensive than a regular string match
(such as `starts_with` or `contains`) so the use of those conditions are
preferred where possible.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.starts_with":"staging-"},{"environment.starts_with":["staging-","running-"]}]}
  groups={[]}
  name={"`[field_name]`.starts_with"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.starts_with

Checks whether a string field starts with a string argument. This may be a
single string or a list of strings, in which case this evaluates to true if any
of the list matches.



</Field>
</Fields>

</Field>
<Field
  common={false}
  defaultValue={30000}
  enumValues={null}
  examples={[30000]}
  groups={[]}
  name={"expire_after_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  warnings={[]}
  >

### expire_after_ms

A maximum period of time to wait after the last event is received before a
combined event should be considered complete.



</Field>
<Field
  common={false}
  defaultValue={1000}
  enumValues={null}
  examples={[1000]}
  groups={[]}
  name={"flush_period_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  warnings={[]}
  >

### flush_period_ms

Controls the frequency that Vector checks for (and flushes) expired events.



</Field>
<Field
  common={true}
  defaultValue={[]}
  enumValues={null}
  examples={[["request_id"],["user_id","transaction_id"]]}
  groups={[]}
  name={"identifier_fields"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"[string]"}
  unit={null}
  warnings={[]}
  >

### identifier_fields

An ordered list of fields by which to group events. Each group is combined
independently, allowing you to keep independent events separate. When no fields
are specified, all events will be combined in a single group. Events missing a
specified field will be combined in their own group.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"merge_strategies"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

### merge_strategies

A map of field names to custom merge strategies. For each field specified this
strategy will be used for combining events rather than the default behavior.

The default behavior is as follows:

1. The first value of a string field is kept, subsequent values are discarded.
2. For timestamp fields the first is kept and a new field `[field-name]_end` is
   added with the last received timestamp value.
3. Numeric values are summed.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={{"array":"Each value is appended to an array.","concat":"Concatenate each string value (delimited with a space).","discard":"Discard all but the first value found.","sum":"Sum all numeric values.","max":"The maximum of all numeric values.","min":"The minimum of all numeric values."}}
  examples={[{"method":"discard"},{"path":"discard"},{"duration_ms":"sum"},{"query":"array"}]}
  groups={[]}
  name={"`[field-name]`"}
  path={"merge_strategies"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`

The custom merge strategy to use for a field.



</Field>
</Fields>

</Field>
</Fields>

## Examples

<Tabs
  block={true}
  defaultValue="default"
  select={false}
  values={[{"label":"Default","value":"default"},{"label":"With Identifier Fields","value":"with-identifier-fields"}]}>

<TabItem value="default">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "reduce"
  inputs = [...]
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "custom_string_field_2": "value2",
  "this_much": 3
}
```

And, finally:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "That thing is concluded",
  "custom_string_field_3": "value3",
  "this_much": 2
}
```

A single log event will eventually be produced:

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "custom_string_field_2": "value2",
  "custom_string_field_3": "value3",
  "this_much": 6
}
```

Notice that string values have not been overridden and integer values have been summed.

</TabItem>

<TabItem value="with-identifier-fields">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "reduce"
  inputs = [...]

  identifier_fields = ["request_id"]

  [transforms.transaction_events.merge_strategies]
    request_action = "array"

  [transforms.transaction_events.ends_when]
    "request_concluded.exists" = true
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": "start",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "request_id": "1",
  "request_action": "bounced",
  "this_much": 2
}
```

And:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "A different thing is happening",
  "request_id": "2",
  "request_action": "start",
  "this_much": 5
}
```

And, finally:

<CodeHeader fileName="fourth log event" />

```javascript
{
  "message": "That thing concluded",
  "request_id": "1",
  "request_action": "rebound",
  "request_concluded": true,
  "this_much": 3
}
```

A single log event will be produced and flushed immediately:

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": ["start","bounced","rebound"]
  "request_concluded": true,
  "this_much": 6
}
```

Notice that the fields from the third event are not present as it has been identified as a separate transaction and will be aggregated separately. Also, the values of the field `request_action` have been stored in an array instead of the default behavior.

</TabItem>
</Tabs>

## How It Works

### Complex Processing

If you encounter limitations with the `reduce`
transform then we recommend using a [runtime transform][urls.vector_programmable_transforms].
These transforms are designed for complex processing and give you the power of
full programming runtime.

### Environment Variables

Environment variables are supported through all of Vector's configuration.
Simply add `${MY_ENV_VAR}` in your Vector configuration file and the variable
will be replaced before being evaluated.

You can learn more in the
[Environment Variables][docs.configuration#environment-variables] section.

[docs.configuration#environment-variables]: /docs/setup/configuration/#environment-variables
[docs.data-model.log]: /docs/about/data-model/log/
[urls.cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
[urls.regex]: https://en.wikipedia.org/wiki/Regular_expression
[urls.rust_regex_syntax]: https://docs.rs/regex/1.3.6/regex/#syntax
[urls.vector_programmable_transforms]: https://vector.dev/components/?functions%5B%5D=program
